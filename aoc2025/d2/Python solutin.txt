Part 2 solution:

the Python solution for part2 works:
def is_repeated_pattern(num):
    """Check if a number is made of a sequence repeated at least twice."""
    s = str(num)
    length = len(s)
First, we convert the number to a string so we can work with individual digits. For example, 1234 becomes "1234".
    # Try all possible pattern lengths from 1 to length//2
    for pattern_len in range(1, length // 2 + 1):
We try every possible pattern length. The pattern can't be longer than half the total length (since it needs to repeat at least twice). For example:
"111" (length 3): try pattern lengths 1
"1234" (length 4): try pattern lengths 1, 2
"123123" (length 6): try pattern lengths 1, 2, 3
        # Check if the string length is divisible by pattern_len
        if length % pattern_len == 0:
The pattern only works if it divides evenly into the total length. For "123123" (length 6):
Pattern length 1: 6 % 1 = 0 ✓
Pattern length 2: 6 % 2 = 0 ✓
Pattern length 3: 6 % 3 = 0 ✓
But for "12345" (length 5):
Pattern length 2: 5 % 2 = 1 ✗ (won't work)
            pattern = s[:pattern_len]
Extract the first pattern_len characters as our candidate pattern. For "123123" with pattern_len=3, we get "123".
            # Skip patterns with leading zeros
            if pattern[0] == '0':
                continue
The problem states no leading zeros, so "0101" isn't valid (though "101" would be).
            # Check if the entire string is this pattern repeated
            repetitions = length // pattern_len
            if pattern * repetitions == s and repetitions >= 2:
                return True
This is the key check:
Calculate how many times the pattern would repeat: repetitions = length // pattern_len
Multiply the pattern by that number: pattern * repetitions
Check if it equals the original string AND repeats at least twice
Examples: For 111:
Try pattern length 1: "1" * 3 = "111" ✓ (3 repetitions ≥ 2)
For 123123:
Try pattern length 3: "123" * 2 = "123123" ✓ (2 repetitions ≥ 2)
For 1212121212:
Try pattern length 2: "12" * 5 = "1212121212" ✓ (5 repetitions ≥ 2)
For 1234:
Try pattern length 1: "1" * 4 = "1111" ✗ (doesn't match)
Try pattern length 2: "12" * 2 = "1212" ✗ (doesn't match)
No match found, returns False
The algorithm is efficient because it only checks divisors of the string length, and it stops as soon as it finds a valid pattern!